#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <assert.h>
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "freertos/timers.h"
#include "freertos/event_groups.h"
#include "nvs_flash.h"
#include "esp_event.h"
#include "esp_netif.h"
#include "esp_wifi.h"
#include "esp_log.h"
#include "esp_system.h"
#include "esp_event.h"
#include "esp_now.h"
#include "esp_crc.h"
#include "esp-now-gw.h"
#include "esp_system.h"
#include <stdio.h>

const uint8_t my_mac[ESP_NOW_ETH_ALEN] = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x00 };

#define QUEUE_SIZE     20
#define MESSAGE_SIZE   50
#define ESP_NOW_TAGLEN 20
#define MAX_TERMINALS  20

enum esp_now_peer_type_t {
    GW,
    SENSOR,
    BUTTON,
    RELAY,
    REPEATER,
    DISPLAY,
    UNKNOWN
};

typedef enum esp_now_peer_type_t esp_now_peer_type_t;

enum esp_now_message_type_t {
    REGISTER,
    CONFIRM,
    SWITCH_HIGH,
    SWITCH_LOW,
    SENSOR_FLOAT_VAL,
    SENSOR_READ,
    RELAY_ON,
    RELAY_OFF,
    RELAY_TOGGLE,
    RELAY_GET,
    DISPLAY_OFF,
    DISPLAY_ON,
    DISPLAY_SET
};
typedef enum esp_now_message_type_t esp_now_message_type_t;

struct esp_now_message_t {
    uint8_t len;
    esp_now_message_type_t type;
    uint8_t message[MESSAGE_SIZE];
};
typedef struct esp_now_message_t esp_now_message_t;

struct register_message_t {
    esp_now_peer_type_t type;
    uint8_t tag[ESP_NOW_TAGLEN];
    uint8_t mac[ESP_NOW_ETH_ALEN];
};
typedef struct register_message_t register_message_t;

struct confirm_message_t {
    uint8_t confirmed;
};
typedef struct confirm_message_t confirm_message_t;

struct esp_now_queue_message_t {
    esp_now_message_t *esp_msg;
    uint8_t mac[ESP_NOW_ETH_ALEN];
    uint8_t esp_msg_len;
};
typedef struct esp_now_queue_message_t esp_now_queue_message_t;

struct esp_now_terminal_t {
    uint8_t peer_mac[ESP_NOW_ETH_ALEN];
    uint8_t dest_mac[ESP_NOW_ETH_ALEN];
    esp_now_peer_type_t peer_type;
    uint8_t peer_tag[ESP_NOW_TAGLEN];
};
typedef struct esp_now_terminal_t esp_now_terminal_t;

static const char *PROG = "espnow_gateway";
static EventGroupHandle_t s_wifi_event_group;
int wifi_retry_num = 0;
static uint8_t broadcast_mac[ESP_NOW_ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
static int npeers = 0;
static esp_now_terminal_t terminals[MAX_TERMINALS];
//static xQueueHandle send_queue;
static SemaphoreHandle_t send_semaphore;
static xQueueHandle recv_queue;
static xQueueHandle send_queue;
static SemaphoreHandle_t terminals_mutex;
static SemaphoreHandle_t send_mutex;
//static SemaphoreHandle_t send_free_mutex;

char* get_type_name(esp_now_peer_type_t type);

static void add_or_update_terminal(uint8_t *peer_mac, uint8_t *dest_mac, esp_now_peer_type_t peer_type, uint8_t *peer_tag) {
    int i;
    bool found = false;
    xSemaphoreTake(terminals_mutex, portMAX_DELAY);
    esp_now_peer_info_t peer;
    memset(&peer,0,sizeof(peer));
    peer.channel = 10;
    peer.ifidx = ESPNOW_WIFI_IF;
    peer.encrypt = false;
    memcpy(peer.peer_addr, dest_mac, ESP_NOW_ETH_ALEN);
    esp_now_peer_info_t pi;
    if (esp_now_get_peer(dest_mac,&pi) == ESP_ERR_ESPNOW_NOT_FOUND) {
        ESP_LOGI(PROG, "Added esp peer");
        esp_now_add_peer(&peer);
    } else {
        ESP_LOGI(PROG, "Modified esp peer");
        esp_now_mod_peer(&peer);
    }
    for (i=0;i<=npeers;i++) {
        if (strcmp((char *)terminals[i].peer_tag, (char *) peer_tag) == 0) {
            ESP_LOGI(PROG, "Updated existing peer");
            found = true;
            memcpy(terminals[i].peer_mac, peer_mac, ESP_NOW_ETH_ALEN);
            memcpy(terminals[i].dest_mac, dest_mac, ESP_NOW_ETH_ALEN);
            terminals[i].peer_type = peer_type;
        }
    }
    if (!found) {
        ESP_LOGI(PROG, "Added new peer");
        memcpy(terminals[npeers].peer_mac, peer_mac, ESP_NOW_ETH_ALEN);
        memcpy(terminals[npeers].dest_mac, dest_mac, ESP_NOW_ETH_ALEN);
        terminals[npeers].peer_type = peer_type;
        strcpy((char *) terminals[npeers].peer_tag, (char *) peer_tag);
        npeers++;
    }
    xSemaphoreGive(terminals_mutex);
    for (i=0;i<npeers;i++) {
        ESP_LOGI(PROG, "Peer no %i",i);
        ESP_LOGI(PROG, "Peer mac %x:%x:%x:%x:%x:%x", terminals[i].peer_mac[0], terminals[i].peer_mac[1], terminals[i].peer_mac[2], terminals[i].peer_mac[3], terminals[i].peer_mac[4], terminals[i].peer_mac[5]);
        ESP_LOGI(PROG, "Dest mac %x:%x:%x:%x:%x:%x", terminals[i].dest_mac[0], terminals[i].dest_mac[1], terminals[i].dest_mac[2], terminals[i].dest_mac[3], terminals[i].dest_mac[4], terminals[i].dest_mac[5]);
        ESP_LOGI(PROG, "Peer type: %s", get_type_name(terminals[i].peer_type));
        ESP_LOGI(PROG, "Peer tag: %s",  terminals[i].peer_tag);
    }
}

static void init_semaphores() {
    terminals_mutex = xSemaphoreCreateMutex();
    send_mutex = xSemaphoreCreateMutex();
    send_semaphore = xSemaphoreCreateBinary();
    if( send_semaphore == NULL ) {
        ESP_LOGI(PROG, "Initial semaphore allocation failed");
        esp_restart();
    }
    if (xSemaphoreGive(send_semaphore) != pdTRUE) {
        ESP_LOGI(PROG, "Initial semaphore give failed");
    }
}

static void asdf() {
    printf("foo\n");
}

static void free_esp_queue_message(esp_now_queue_message_t *msg) {
    esp_now_message_t *esp_msg;
    esp_msg = msg->esp_msg;
    switch(esp_msg->type) {
    case REGISTER:
        ESP_LOGI(PROG, "Freeign register message");
        register_message_t *reg_msg;
        reg_msg = (register_message_t *) esp_msg->message;
        free(reg_msg);
        free(esp_msg);
        free(msg);
        break;
    case CONFIRM:
        ESP_LOGI(PROG, "Freeign confirm message");
        confirm_message_t *confirm_msg;
        confirm_msg = (confirm_message_t *) esp_msg->message;
        free(confirm_msg);
        free(esp_msg);
        free(msg);
        break;
    default:
        ESP_LOGI(PROG, "Unkown message type, can't free");
        break;
    }
}

char* get_type_name(esp_now_peer_type_t type) {
    switch(type) {
    case GW:
        return "GW";
        break;
    case SENSOR:
        return "SENSOR";
        break;
    case BUTTON:
        return "BUTTON";
        break;
    case RELAY:
        return "RELAY";
        break;
    case REPEATER:
        return "REPEATER";
        break;
    default:
        return "UNKNOWN";
    }
}

static void esp_now_recv_task(void *foo) {

    BaseType_t retval_dequeue, retval_enqueue;
    esp_now_queue_message_t *esp_now_queue_msg;
    esp_now_message_t *msg;

    ESP_LOGI(PROG, "Started to pull queue");
    for (;;) {
        ESP_LOGI(PROG,"Waiting for message");
        retval_dequeue = xQueueReceive( recv_queue, &esp_now_queue_msg, portMAX_DELAY);
        if ( retval_dequeue == pdTRUE ) {
            ESP_LOGI(PROG, "Recieve message, length=%i", esp_now_queue_msg->esp_msg_len);
            msg = esp_now_queue_msg->esp_msg;
            switch(msg->type) {
            case REGISTER:
                ESP_LOGI(PROG, "Dequeued register msg");
                register_message_t reg_msg;
                memcpy((void *) &reg_msg, msg->message, sizeof(register_message_t));
                add_or_update_terminal(reg_msg.mac, esp_now_queue_msg->mac, reg_msg.type, reg_msg.tag);
                confirm_message_t *confirm_msg;
                esp_now_message_t *send_esp_msg;
                esp_now_queue_message_t *send_esp_queue_msg;
                confirm_msg = malloc(sizeof(confirm_message_t));
                confirm_msg->confirmed = 1;
                send_esp_msg = malloc(sizeof(esp_now_message_t));
                send_esp_msg->len=sizeof(confirm_message_t);
                send_esp_msg->type=CONFIRM;
                memcpy(send_esp_msg->message, confirm_msg, sizeof(confirm_message_t));
                send_esp_queue_msg = malloc(sizeof(esp_now_queue_message_t));
                send_esp_queue_msg->esp_msg = send_esp_msg;
                memcpy(send_esp_queue_msg->mac, esp_now_queue_msg->mac, ESP_NOW_ETH_ALEN);
                send_esp_queue_msg->esp_msg = send_esp_msg;
                send_esp_queue_msg->esp_msg_len = sizeof(esp_now_message_t);
                ESP_LOGI(PROG, "Enqueueing confirm msg");
                retval_enqueue = xQueueSend(send_queue, (void *) &send_esp_queue_msg, portMAX_DELAY);
                if (retval_enqueue == pdTRUE) {
                    ESP_LOGI(PROG, "Enqueue successful");
                } else {
                    ESP_LOGI(PROG, "Enqueue failed");
                }
                break;
            default:
                ESP_LOGI(PROG, "Recieved unsupported message type");
                break;
            }
        } else {
            ESP_LOGI(PROG, "strange dequeue error");
        }

        free(esp_now_queue_msg->esp_msg);
        free(esp_now_queue_msg);
    }
}

static void my_espnow_recv_cb(const uint8_t *mac_addr, const uint8_t *data, int len) {

    esp_now_queue_message_t *queue_msg;
    BaseType_t enqueue_retval;

    queue_msg = (esp_now_queue_message_t *) malloc(sizeof(esp_now_queue_message_t));
    queue_msg->esp_msg = (esp_now_message_t *) malloc(sizeof(esp_now_message_t));
    memcpy(queue_msg->mac, mac_addr, ESP_NOW_ETH_ALEN);
    queue_msg->esp_msg_len = len;
    memcpy(queue_msg->esp_msg, data, len);
    ESP_LOGI(PROG, "Enqueuing message");
    enqueue_retval = xQueueSend(recv_queue, (void *) &queue_msg, 0);

    if ( enqueue_retval == pdTRUE ) {
        ESP_LOGI(PROG, "ESP_NOW_RECV callback, enqueued message sucessfully");
    } else {
        ESP_LOGI(PROG, "ESP_NOW_RECV callback, failed to enqueue message");
    }
    ESP_LOGI(PROG, "RECV_CALLBACK finished");
}

static void my_espnow_send_cb(const uint8_t *mac_addr, esp_now_send_status_t status) {
    ESP_LOGI(PROG, "ESP_NOW_SEND callback, returning mutex");
    if (status == ESP_NOW_SEND_SUCCESS ) {
        ESP_LOGI(PROG, "ESP_NOW_SEND callback, status SUCCESS ");
    } else {
        ESP_LOGI(PROG, "ESP_NOW_SEND callback, status FAILURE");
    }
}

static void send_task() {
    BaseType_t retval_dequeue;
    esp_now_queue_message_t *esp_now_queue_msg;
    esp_now_message_t *msg;

    ESP_LOGI(PROG, "Send task: Started to pull queue");
    for (;;) {
        ESP_LOGI(PROG,"Send task: Waiting for message");
        retval_dequeue = xQueueReceive( send_queue, &esp_now_queue_msg, portMAX_DELAY);
        if ( retval_dequeue == pdTRUE ) {
            ESP_LOGI(PROG, "Send message, length=%i", esp_now_queue_msg->esp_msg_len);
            msg = esp_now_queue_msg->esp_msg;
            ESP_LOGI(PROG, "Send message, taking mutex");

            ESP_LOGI(PROG, "Send message, mutex taken");
            ESP_LOGI(PROG, "Sending message to %x:%x:%x:%x:%x:%x", esp_now_queue_msg->mac[0], esp_now_queue_msg->mac[1], esp_now_queue_msg->mac[2], esp_now_queue_msg->mac[3], esp_now_queue_msg->mac[4], esp_now_queue_msg->mac[5]);
            esp_now_send(esp_now_queue_msg->mac, (const uint8_t *) msg, sizeof(esp_now_message_t));
            vTaskDelay(500 / portTICK_PERIOD_MS);
            ESP_LOGI(PROG, "Send message, message sent");
        } else {
            ESP_LOGI(PROG, "Send task: failed to dequeue message");
        }
        // TODO: free memory allocated in queue messages
    }
}

static void wifi_event_handler(void* arg, esp_event_base_t event_base,
                               int32_t event_id, void* event_data) {
    asdf();
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        if (wifi_retry_num < WIFI_MAX_RETRY) {
            esp_wifi_connect();
            wifi_retry_num++;
            ESP_LOGI(PROG, "ESP_STA retry to connect to the AP");
        } else {
            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);
        }
        ESP_LOGI(PROG, "ERROR connect to the AP fail");
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(PROG, "got ip:" IPSTR, IP2STR(&event->ip_info.ip));
        wifi_retry_num = 0;
        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);
    }
}

void init_wifi() {

    s_wifi_event_group = xEventGroupCreate();
    ESP_ERROR_CHECK(esp_netif_init());

    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_sta();
    esp_netif_create_default_wifi_ap();

    wifi_init_config_t sta_init_config = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&sta_init_config));


    esp_event_handler_instance_t instance_any_id;
    esp_event_handler_instance_t instance_got_ip;
    esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL, &instance_any_id);
    esp_event_handler_instance_register(IP_EVENT,
                                        IP_EVENT_STA_GOT_IP,
                                        &wifi_event_handler,
                                        NULL,
                                        &instance_got_ip);

    ESP_LOGI(PROG,"Event handlers registered");
    wifi_config_t sta_wifi_config = {
        .sta = {
            .ssid = STA_WIFI_SSID,
            .password = STA_WIFI_PASSWORD,
            .threshold.authmode = WIFI_AUTH_OPEN,
            .pmf_cfg = {
                .capable = true,
                .required = false
            },
        },
    };
    wifi_config_t ap_wifi_config = {
        .ap = {
            .ssid = AP_WIFI_SSID,
            .password = AP_WIFI_PASSWORD,
            .authmode = WIFI_AUTH_OPEN,
            .channel  = 10,
            .max_connection = 15
        },
    };
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_APSTA) );
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &sta_wifi_config) );
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &ap_wifi_config) );
    ESP_ERROR_CHECK(esp_wifi_start() );

    ESP_LOGI(PROG, "wifi_init_apsta finished.");
    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,
                                           WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,
                                           pdFALSE,
                                           pdFALSE,
                                           portMAX_DELAY);
    if (bits & WIFI_CONNECTED_BIT) {
        ESP_LOGI(PROG, "connected to ap SSID: %s", STA_WIFI_SSID);
    } else if (bits & WIFI_FAIL_BIT) {
        ESP_LOGI(PROG, "Failed to connect to SSID: %s",STA_WIFI_SSID);
    } else {
        ESP_LOGE(PROG, "UNEXPECTED EVENT");
    }
}


void my_esp_now_init() {
    esp_now_init();
    esp_now_register_send_cb(my_espnow_send_cb);
    esp_now_register_recv_cb(my_espnow_recv_cb);
    // Add broadcast peer
    esp_now_peer_info_t *peer = malloc(sizeof(esp_now_peer_info_t));
    memset(peer, 0, sizeof(esp_now_peer_info_t));
    peer->channel = 10;
    peer->ifidx = ESPNOW_WIFI_IF;
    peer->encrypt = false;
    memcpy(peer->peer_addr, broadcast_mac, ESP_NOW_ETH_ALEN);
    esp_now_add_peer(peer);
}

void app_main(void) {

    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK( nvs_flash_erase() );
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK( ret );
    ESP_ERROR_CHECK(esp_base_mac_addr_set(my_mac));
    init_semaphores();
    asdf();
    init_wifi();
    asdf();
    my_esp_now_init();

    recv_queue = xQueueCreate(QUEUE_SIZE, sizeof(esp_now_queue_message_t));
    send_queue = xQueueCreate(QUEUE_SIZE, sizeof(esp_now_queue_message_t));
    xTaskCreate(esp_now_recv_task, "esp_now_recv_task", 32*1024, NULL, 1, NULL);
    xTaskCreate(send_task, "esp_now_send_task", 32*1024, NULL, 1, NULL);
}
